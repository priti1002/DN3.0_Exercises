1.Understand Search Algorithms

Q.Explain linear search and binary search algorithms.
Ans.
linear search=>
Algorithm Steps:
1.Start from the beginning of the list.
2.Compare the target value with the current element.
3.If the current element matches the target value, return the index of the element.
4.If the current element does not match, move to the next element.
5.Repeat steps 2-4 until you either find the target element or reach the end of the list.
6.If the end of the list is reached and the element is not found, return an indication that the element is not present (e.g., -1).

binary search=>
Algorithm Steps:
1.Start with the entire list as the search interval.
2.Find the middle element of the current interval.
3.Compare the target value with the middle element:
  .If the target value is equal to the middle element, return the index of the middle element.
  .If the target value is less than the middle element, narrow the search to the left half of the interval.
  .If the target value is greater than the middle element, narrow the search to the right half of the interval.
7.Repeat steps 2-3 until the target element is found or the search interval is empty.
8.If the interval is empty and the target element has not been found, return an indication that the element is not present (e.g., -1).


4. Analysis

Q.Compare the time complexity of linear and binary search ?
Ans.
Linear Search:
Best Case: O(1) (if the element is the first one)
Average Case: O(n)
Worst Case: O(n)
Binary Search:
Best Case: O(1) (if the element is the middle one)
Average Case: O(log n)
Worst Case: O(log n)

Q.Discuss when to use each algorithm based on the data set size and order?
Ans.
Linear Search:
1.Suitable for small or unsorted datasets.
2.Simple to implement and does not require the data to be sorted.
3.Useful when the cost of sorting the data outweighs the benefits of faster searches.
Binary Search:
1.Suitable for large, sorted datasets.
2.Requires initial sorting of the data, which can be time-consuming but allows for much faster search times afterwards.
3.Ideal when multiple searches are needed on a static dataset, as the overhead of sorting is amortized over many search operations.