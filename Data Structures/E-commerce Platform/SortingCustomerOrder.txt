1. Understand Sorting Algorithms

Q.Explain different sorting algorithms (Bubble Sort, Insertion Sort, Quick Sort, Merge Sort).
Ans.
Bubble Sort=>

Definition: Bubble Sort is a simple comparison-based sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This process continues until the list is sorted.

Time Complexity:
Best Case: 𝑂(𝑛)
           (when the list is already sorted, but in practice, Bubble Sort is usually  𝑂(𝑛^2)due to unnecessary comparisons).
Average Case: 𝑂(𝑛^2)
 Worst Case:𝑂(𝑛^2)


Algorithm Steps:
1.Iterate through the list from the beginning.
2.Compare adjacent elements and swap them if they are out of order.
3.Continue the process until no more swaps are needed.

 Insertion Sort=>

Definition: Insertion Sort builds the final sorted array one item at a time by repeatedly picking the next item from the unsorted portion and inserting it into its correct position in the sorted portion.

Time Complexity:
Best Case: 𝑂(𝑛)
Average Case: 𝑂(𝑛^2)
 Worst Case:𝑂(𝑛^2)

Algorithm Steps:
1.Start with the second element and compare it with the elements before it.
2.Move the element to its correct position by shifting larger elements to the right.
3.Continue until the end of the list is reached

Quick Sort=>

Definition: Quick Sort is a divide-and-conquer algorithm that picks an element as a pivot and partitions the array around the pivot. The sub-arrays are then sorted recursively.

Time Complexity:
Best Case: 𝑂(nlogn)
Average Case: 𝑂(nlogn)
 Worst Case:𝑂(𝑛^2)

Algorithm Steps:
1.Choose a pivot element from the array.
2.Partition the array into two sub-arrays: elements less than the pivot and elements greater than the pivot.
3.Recursively apply Quick Sort to the sub-arrays.

Merge Sort=>

Definition: Merge Sort is a divide-and-conquer algorithm that divides the array into halves, recursively sorts each half, and then merges the sorted halves back together.

Time Complexity:
Best Case: 𝑂(nlogn)
Average Case: 𝑂(nlogn)
 Worst Case:𝑂(nlogn)

Algorithm Steps:
1.Divide the array into two halves.
2.Recursively sort each half.
3.Merge the two sorted halves into a single sorted array.


4. Analysis

Q.Compare the performance (time complexity) of Bubble Sort and Quick Sort?
Ans.
Bubble Sort=>
Best Case: O(n)
Average Case: O(n^2)
Worst Case: O(n^2)

Quick Sort=>
Best Case: O(n log n)
Average Case: O(n log n)
Worst Case: O(n^2) (but rare with good pivot selection)

Q.Discuss why Quick Sort is generally preferred over Bubble Sort.

Ans.
1.Efficiency: Quick Sort's average and best-case time complexity of O(n log n) makes it much faster for large datasets compared to Bubble Sort’s O(n^2).
2.Scalability: Quick Sort can handle large arrays more efficiently and is well-suited for in-place sorting.
3.Practical Performance: In practice, Quick Sort is faster than Bubble Sort for most inputs due to lower constants and better cache performance.


